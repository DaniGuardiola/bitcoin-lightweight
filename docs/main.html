<!DOCTYPE html>

<html>
<head>
  <title>main.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="main.html">
                  main.js
                </a>
              
                
                <a class="source" href="test.html">
                  test.js
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>main.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> WALLET_TYPES = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./dictionaries/wallet-types'</span>)

<span class="hljs-keyword">const</span> createWallet = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./lib/create-wallet'</span>)
<span class="hljs-keyword">const</span> Joi = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./lib/joi'</span>)

<span class="hljs-keyword">const</span> Mnemonic = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bitcore-mnemonic'</span>)
<span class="hljs-keyword">const</span> {
  HDPrivateKey,
  Networks
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bitcore-lib'</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>constants</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">const</span> WALLET_TYPE_LIST = <span class="hljs-built_in">Object</span>.keys(WALLET_TYPES)
<span class="hljs-keyword">const</span> DEFAULT_GAP_LIMIT = <span class="hljs-number">20</span>
<span class="hljs-keyword">const</span> CHANGE_GAP_LIMIT = <span class="hljs-number">5</span>

<span class="hljs-comment">/**
 * Abstracts the logic of wallets, supporting multiple types for multiple currencies.
 *
 * @param {string} type Type of wallet
 * @param {string|object} secret Private information that provides full access to the wallet
 */</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wallet</span> </span>{
  <span class="hljs-comment">/**
   * Creates a new wallet
   *
   * @param  {string} type    Wallet type
   * @param  {object} options Options for wallet creation
   * @return {Wallet}         Wallet instance
   */</span>
  <span class="hljs-keyword">static</span> create (type, options = {}) {
    <span class="hljs-keyword">const</span> { secret } = createWallet[type](options)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Wallet(type, secret)
  }

  <span class="hljs-keyword">constructor</span> (typeId, secret, options = {}) {</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>validate and store wallet type</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    typeId = Joi.attempt(typeId,
      Joi.string().valid(WALLET_TYPE_LIST).required())

    <span class="hljs-keyword">this</span>._type = WALLET_TYPES[typeId]</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>validate and store secret</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._secret = Joi.attempt(secret, <span class="hljs-keyword">this</span>._type.secretSchema)</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>validate and store options</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    options = Joi.attempt(options,
      Joi.object({
        <span class="hljs-attr">network</span>: Joi.string().valid([<span class="hljs-string">'livenet'</span>, <span class="hljs-string">'testnet'</span>]).default(<span class="hljs-string">'livenet'</span>),
        <span class="hljs-attr">gapLimit</span>: Joi.number().integer().positive().max(<span class="hljs-number">100</span>).default(DEFAULT_GAP_LIMIT)
      }))

    <span class="hljs-keyword">this</span>._network = Networks.get(options.network)
    <span class="hljs-keyword">this</span>._gapLimit = options.gapLimit</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>initialization</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._initialized = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">this</span>._initializationPromise = <span class="hljs-keyword">this</span>._initialize()
  }
  <span class="hljs-keyword">async</span> _ensureInitialized () {</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>this method is intended to be used at the start of any method that needs the wallet
to be already initialized</p>

            </div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>it can be used in async functions by adding this at the top: await this._ensureInitialized()</p>

            </div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>this will ensure that the function will only be run after initialization</p>

            </div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>TODO: include timeout?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._initialized) <span class="hljs-keyword">return</span>

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._initializationPromise) <span class="hljs-keyword">this</span>._initializationPromise = <span class="hljs-keyword">this</span>._initialize()

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._initializationPromise
  }

  <span class="hljs-keyword">async</span> _initialize () {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>TODO: include timeout?</p>

            </div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>initialize secret</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    ;({
      <span class="hljs-attr">BIP39</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>._initializeBIP39Secret(),
      <span class="hljs-attr">BIP32</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>._initializeBIP32Secret()
    })[<span class="hljs-keyword">this</span>._type.secretType]()</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>initialize wallet</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    ;({
      <span class="hljs-attr">BIP39</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>._initializeBIP32Wallet(),
      <span class="hljs-attr">BIP32</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>._initializeBIP32Wallet()
    })[<span class="hljs-keyword">this</span>._type.secretType]()</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>update initialization-related state props</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._initialized = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">this</span>._initializationPromise = <span class="hljs-literal">false</span>
  }

  <span class="hljs-keyword">async</span> _initializeBIP39Secret () {
    <span class="hljs-keyword">const</span> stringFormat = <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>._secret === <span class="hljs-string">'string'</span>

    <span class="hljs-keyword">const</span> seed = stringFormat ? <span class="hljs-keyword">this</span>._secret : <span class="hljs-keyword">this</span>._secret.seed
    <span class="hljs-keyword">const</span> passphrase = stringFormat ? <span class="hljs-literal">null</span> : <span class="hljs-keyword">this</span>._secret.passphrase</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>derive and store HD private key from mnemonic</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">const</span> mnemonic = <span class="hljs-keyword">new</span> Mnemonic(seed)
    <span class="hljs-keyword">this</span>._rootHDPrivateKey = mnemonic
      .toHDPrivateKey(passphrase, <span class="hljs-keyword">this</span>._network)
  }

  <span class="hljs-keyword">async</span> _initializeBIP32Secret () {
    <span class="hljs-keyword">this</span>._rootHDPrivateKey = <span class="hljs-keyword">new</span> HDPrivateKey(<span class="hljs-keyword">this</span>._secret, <span class="hljs-keyword">this</span>._network) <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> not sure if network works here</span>
  }

  <span class="hljs-keyword">async</span> _initializeBIP32Wallet () {</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>TODO: optionally load from storage and update addresses from that</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">const</span> BIP44CoinType = <span class="hljs-keyword">this</span>._type.BIP44CoinTypes[<span class="hljs-keyword">this</span>._network.name]</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>get BIP 44 main account, external and change HD keys</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">const</span> mainAccountHDPrivateKey = <span class="hljs-keyword">this</span>._rootHDPrivateKey.derive(<span class="hljs-string">`m/44'/<span class="hljs-subst">${BIP44CoinType}</span>'/0'`</span>)
    <span class="hljs-keyword">this</span>._mainAccountHDPrivateKeys = {
      <span class="hljs-attr">external</span>: mainAccountHDPrivateKey.derive(<span class="hljs-number">0</span>),
      <span class="hljs-attr">change</span>: mainAccountHDPrivateKey.derive(<span class="hljs-number">1</span>)
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>generate the initial external and change addresses</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._addresses = {
      <span class="hljs-attr">external</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">this</span>._gapLimit).fill().map(<span class="hljs-function">(<span class="hljs-params">value, index</span>) =&gt;</span> <span class="hljs-keyword">this</span>._deriveAddress(<span class="hljs-string">'external'</span>, index)),
      <span class="hljs-attr">change</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(CHANGE_GAP_LIMIT).fill().map(<span class="hljs-function">(<span class="hljs-params">value, index</span>) =&gt;</span> <span class="hljs-keyword">this</span>._deriveAddress(<span class="hljs-string">'change'</span>, index)),
      get externalLastIndex () { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.external.length - <span class="hljs-number">1</span> },
      get changeLastIndex () { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.change.length - <span class="hljs-number">1</span> }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>check transaction history to keep generating addresses until the last 5
are new, like electrum does
TODO</p>

            </div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>TODO:</p>
<ul>
<li>categorize addresses somehow (change and receiving)</li>
<li>add more protection and complexity to address generation (non-linear derivation paths)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  }

  _deriveAddress (type, index) {
    <span class="hljs-keyword">const</span> hdPrivateKey = <span class="hljs-keyword">this</span>._mainAccountHDPrivateKeys[type].derive(index)
    <span class="hljs-keyword">const</span> privateKey = hdPrivateKey.privateKey
    <span class="hljs-keyword">const</span> publicKey = hdPrivateKey.publicKey
    <span class="hljs-keyword">const</span> address = privateKey.toAddress()

    <span class="hljs-keyword">return</span> {
      privateKey,
      publicKey,
      address,
      <span class="hljs-attr">used</span>: <span class="hljs-string">'unknown'</span>,
      <span class="hljs-attr">updated</span>: <span class="hljs-literal">false</span>
    }
  }

  <span class="hljs-comment">/**
   * Retrieves the current wallet balance and the estimation for the secondary currency
   *
   * @async
   * @param  {object} options Options for the getBalance operation
   * @param  {string} options.secondaryCurrency Overwrites the secondary currency setting
   * @param  {string} options.withSymbol Returns strings with the currency symbol appended instead of just numbers for balances
   *
   * @return {Promise&lt;{balance: number, secondary: {balance: number, currency: string}}&gt;} Object that contains the balance of the wallet currency and the secondary currency information
   */</span>
  <span class="hljs-keyword">async</span> getBalance (options = {}) {
    <span class="hljs-comment">/*
      Using electrum-client, either:
      - retrieve balances for all addresses
      - calculate balance from the history

      The latter is probably the best option, to reduce bandwith and improve offline resilience.

      The balance should be stored in the local database and then updated everytime new transactions
      are pulled for the wallet's addresses.

      Formatting options (like returning strings with an appended currency symbol with i18n instead of
      just the numbers) should be included.
    */</span>
  }

  <span class="hljs-keyword">async</span> getTransactionHistory (options = {}) {
    <span class="hljs-comment">/*
      Using electrum-client, retrieve all historic transactions with all the data for all of the
      wallet's addresses.

      The history should be stored in the local database and updated everytime new transactions are
      pulled.

      There should be pagination based on either:
      - Number of transaction from the start
      - Id of the last transaction pulled (the most recent or the oldest depending on direction)

      There shouldn't be paagination based on inverse number of transaction because this could cause
      offset problems when a transaction is made inbetween pages.

      This method might include filtering options to facilitate search.

      Additionally, if non-blockchain metadata is stored in owned servers, the appropiate requests should
      be made (with proper cache).

      Also we might want to include the option to let the user store non-blockchain transaction metadata
      locally, so all of this data should be combined properly. We might want to do it in an asynchronous fashion
      to allow for optimal app responsiveness (e. g. displaying pure blockchain tx data first, and then updating
      with additional metadata when ready).

      We might want to split this into different methods or provide a different async interface, as promises only
      fullfill once and that's it, while this would require different stages. Might be worth it to consider the use
      of observables (reactivex.io), streams or similar.

      Formatting options (like returning strings with an appended currency symbol with i18n instead of
      just the numbers) should be included.
    */</span>
  }
}</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>TODO: user-friendly error messages instead of Joi’s? <a href="https://github.com/hapijs/joi/issues/546">https://github.com/hapijs/joi/issues/546</a></p>

            </div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
